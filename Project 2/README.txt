Project 2 - K24 - Unix Systems Programming
Θοδωρής Μπανιώκος - 1115201800121 - sdi1800121@di.uoa.gr
Το συγκερκιμένο αρχείο περιέχει πληροφορίες για το compiliation, τις σχεδιαστικές επιλογές και τον κώδικα.

- Οργάνωση αρχείων και φακέλων του project

• Στο project αυτό:
    Τα αρχεία με τον source code βρίσκονται στον φάκελο src σε ξεχωριστούς υποφακέλους για κάθε δομή / λειτουργεία του προγράμματος
    Επίσης κάποια κομμάτια κώδικα είναι μόνο του travelMonitor, κάποια του monitor και κάποια είναι κοινά, αυτά χωρίζονται στους φακέλους src/trvl_mon, src/mon, src/common_impls αντίστοιχα
    Τα Header αρχεία βρίσκονται στον φάκελο inc
    Στον φάκελο sample υπάρχει ένα sample αρχείο για την δημιουργία του input directory μέσω του bash script
    Στον κεντρικό φάκελο υπάρχει το Makefile το bash script και το README

- Compilation

• Για να γίνει compile του κώδικα αρκεί να εκτελεστεί η παρακάτω εντολή στον κεντρικό φάκελο του project:

    make -s (για να μην εμφανίζεται το κάθε αρχείο που γίνεται compile) ή απλα make

• Για να γίνει compile του κώδικα και εκτέλεση του προγράμματος αμέσως μετά αρκεί να εκτελεστεί η παρακάτω εντολή στον κεντρικό φάκελο του project:

    make run

    Η παραπάνω εντολή φτιάχνει και τον φάκελο input_dir μέσω του bash script

• Για να καθαριστούν οι φάκελοι του project και να διαγραφθούν τα binaries αρκεί να εκτελεστεί η παρακάτω εντολή στον κεντρικό φάκελο του project:

    make clean

• Για να καθαριστούν οι φάκελοι του project και να διαγραφθούν τα binaries και τα εκτελέσιμα αρκεί να εκτελεστεί η παρακάτω εντολή στον κεντρικό φάκελο του project:

    make fullclean

• Για να εκτελεστεί το πρόγραμμα σε debug state αρκεί να εκτελεστεί η παρακάτω εντολή στον κεντρικό φάκελο του project, και να είναι εγκατεστημένο το εργαλείο valgrind:

    make valgrind

- Εκτέλεση προγράμματος

• Για να εκτελεστεί το πρόγραμμα πρέπει πρώτα να γίνει μεταγλώτιση και έπειτα να εκτελεστεί η παρακάτω εντολή στον κεντρικό φάκελο του project:
    ./travelMonitor –m numMonitors -b bufferSize -s sizeOfBloom -i input_dir

    Με:
        numMonitors -> ο αριθμός των monitor processes που θα εκτελεστούν
        bufferSize -> το μέγεθος του buffer που χρησιμοποιείται για διαβασμα και γράψιμο *σε bytes*
        sizeOfBloom -> το μέγεθος του bloom filter που χρησιμοποιείται στο travelMonitor και monitor *σε bytes*
        input_dir -> ο φάκελος με τα αρχεία των χωρών

• Όπου αρχικά πρέπει να έχει γίνει και δημιουργία του input_dir αν δεν υπάρχει ήδη, για να γίνει αυτό πρέπει να εκτελεστεί η εντολή:

    ./create_infiles.sh inputFile input_dir numFilesPerDirectory

    inputFile : Περιέχει στοιχεία πολιτών και εγγραφές για εμβολιασμους
    input_dir : Το όνομα του φακέλου που θα φτιαχτεί και θα περιέχει τα στοιχεία των πολίτων χωρισμένα ανα χώρα σε υποφακέλους
    numFilesPerDirectory : Ο αριθμός των αρχείων που θα έχει ο κάθε υποφάκελος

- Σχεδιαστικές επιλογές

• Δομές:
    Στο project έχουν χρησιμοποιηθεί ακριβώς οι ίδιες δομές δεδομένων που υπήρχαν στο project 1 με ακριβώς τις ίδιες generic υλοποιήσεις με τη μόνη διαφορά να είναι
    ο πιο εκτεταμένος έλεγχος για σωστό allocation μνήμης, μέσω της assert()

    Η αποθήκευση όλων των δομών είναι ακριβώς η ίδια με το πρώτο project όπως και η αποθήκευση των δεδομένων που υπάρχουν στα αρχεία.

    Έχει δημιουργηθει ένα struct (struct MonitorProcesInfo, δήλωση στο αρχείο travelMonitorHelpersIntr.h) για να αποθηκεύονται όλες οι πληροφορίες για τα ξεχωριστά monitors
    σε ένα container για κάθε ένα από τα διαφορετικά monitor processes

    Έχει δημιουργηθει ένα struct (struct Request_Stats, δήλωση στο αρχείο Types.h) για να αποθηκεύονται τα στατιστικά των queries που έγιναν αποδεκτά ή όχι του κάθε process

    Έχουν δημιουργηθει δυο structs (struct ht_container, struct request_information) τα οποία βοηθάνε στην αποθήκευση των απαραίτητων πληροφοριών για την σωστή λειτουργία του
    query /travelStats virusName date1 date2 [country]

- Λειτουργικότητα εφαρμογής

• Η αρχικοποίηση των δομών δεδομένων γίνεται ακριβώς όπως γίνεται και στο πρώτο project

• Για την επικοινωνία των διεργασιών μέσω των named pipes έχει φτιαχτεί ένα custom προτόκολο το οποίο οτιδήποτε χρειάζεται να σταλθεί το μετατρέπει σε string, μια παραδοχή που γίνεται είναι
  πως στην αρχή κατα τη δημιουργία των monitor processes στέλνετε το μέγεθος του buffer υπολογίζοντας το πόσο μέγεθος χρειάζεται το νούμερο που χρειάζεται αυτο το οποίο έχει δοθεί ως buffer size
  για να αναπαρασταθεί σε string, το μέγιστο μέγεθος είναι 11 (10 + το null terminator χαρακτήρα).

• Κάθε μήνυμα που στέλνετε μέσω των pipes αποτελείται από ένα κωδικό μηνύματος, ο οποίος πάντα είναι στην πρώτη θέση του string που φτιαχνεται για το μηνυμα και επειδή δεν υπάρχουν κωδικοί μεγαλύτεροι
  απο 127 δε χρειάζεται να γίνει καποιο conversion σε string, έπειτα βρίσκεται το μέγεθος του μηνυματος που θα στείλουμε, το header δηλαδή, το οποίο είναι ένα string το πολύ 11 χαρακτήρων
  *10 για το μέγιστο αριθμό χαρακτήρων που χρειάζεται για να αναπαρασταθεί το int max + το null terminator* που είναι το πόσοι χαρακτήρες υπάρχουν στο μήνυμα, αν το μέγεθος είναι 100 για πααρδειγμα τοτε
  όλες οι υπόλοιπες θέσεις αυτού του string γεμίζουν με μηδενικα (δηλαδή το format ειναι αυτού του τύπου : 0000000100). Έπειτα στο τέλος του string που είναι όλο το μήνυμα βρίσκεται οτι πρεπει να περναει
  απο process σε process, καποιο query η καποιο bloom filter πχ. Καθε ένα απο τα queries και καθε λειτουργεια μεταφοράς, μεγεθος buffer/μεγεθος bloom filter/bloom filter etc έχει το δικό του κωδικό για μηνυμα.
  Για να ξέρει ο παραλήπτης ότι ο αποστολέας σταμάτησε να στέλνει μηνυματα υπαρχει και ένας εξτρα κωδικος για αυτο το λογο.

• Η αποστολή του μηνυματος γινεται ανάλογα με το πόσο μεγαλο είναι το μήνυμα και το πόσα bytes πρεπει να στείλουμε ακόμα. Αρχικά φτιαχνεται ένα string το οποίο είναι το μήνυμα πρέπει να σταλθεί και δίνεται έτοιμο,
  το μηνυμα, έπειτα φτιαχνεται το full μηνυμα με τον κωδικο που δίνεται, το μεγεθος του μηνυματος και το μηνυμα και αποθηκεύεται το μεγεθος για να χρησιμοποιηθεί
  στην λουπα. Έπειτα στη λουπα ελέγχουμε κάθε φορα αν ο αριθμος των bytes που έχει σταλθει είναι μικρότερος από το συνολικο μέγεθος, υπολογίζεται η διαφορά και ελέγχουμε ποια τιμή είναι μεγαλύτερη
  μεταξύ διαφορας μεγεθους μηνυματος και μεγεθους buffer και ανάλογα με το αν η διαφορά έιναι μικρότερη από το buffer χρησιμοποιείται αυτο το νουμερο στο write() syscall για το ποσα bytes θα γραφτουν
  αλλιως χρησιμοποιήτε το μέγεθος του buffer.

• Η λήψη γίνεται σταδιακά και με τη βοήθεια μιας ακόμα συνάρτησης. Πρώτα θα διαβαστεί το byte που αποθηκεύεται ο κωδικός, μετά θα διαβαστουν τα bytes που χρειάζονται για το header και μετά όσα bytes
  λεει το header. Το κάθε ένα από αυτα γίνεται μέσω της read_specified_bytes η οποία λειτουργεί με μια λουπα, για  όσο τα bytes που έχουμε ήδη λάβει είναι λιγότερα, ελέγχουμε τη διαφορά από το πόσα bytes έχουμε να διαβασουμε
  τα οποία δίνονται ως όρισμα με αυτά που έχουμε διαβάσει μέχρι εκείνη τη στιγμή και ανάλογα το αν είναι μικρότερο νούμερο η διαφορα η το buffer size επιλέγουμε αυτο το νούμερο για διαβασμα στο buffer από το read() syscall.
  Αν εκείνη τη στιγμή υπάρχει κάποιο interupt από σήμα η το errno είναι EAGAIN απλά κάνουμε ignore με ένα continue.

• Ο συγχρονισμος των διεργασιών γίνεται μέσω της poll. Κάθε κελι του πίνακα που αποθηκεύονται τα δεδμένα των διεργασιών έχει ένα struct pollfd πίνακα με τα αντίστοιχα file descriptors και τα αντίστοιχα τα events.
  Επίσης για το query /seacrhVaccinationStatus και το διαβασμα των bloom filters από κάθε διεργασία υπάρχει ένα struct pollfd για όλα τα file descriptors και τα events τους και πάντα διαβάζει από αυτό το process
  το οποίο είναι έτοιμο να γράψει.

• Επίσης ο έλεγχος για τα σήματα:
    Για το travelMonitor τα sigint και sigquit γίνονται πριν το πρόγραμμα μπει σε state να περιμένει για user input διότι πρέπει πρώτα να τελειώσει με το query που έχει λάβει και το sigchld αμέσως μετά από το διάβασμα
    του user input διότι μπορεί να "πεθάνει" ενα παιδί και να πρεπει να πάει σε αυτό το παιδί το query.

    Για το monitor γίνεται πριν ελεγχθει το αν υπαρχει έτοιμος file descriptor από την poll().
    To sigquit στο monitor κάνει το παιδί να πεθένει, οπότε φτιαχνεται και καινούργιο παιδί.

- Γενικά

• Γίνεται έλεγχος για το αν δίνονται σωστά γραμμένες οι εντολές.

• Τα arguments των εντολών έχουν συγκερκιμένο format οπότε δε γίνεται κάποιος έλεγχος για αυτά, όπως έχουν τονίσει οι διδάσκωντες/βοηθοί. Αν δωθούν λάθος ορίσματα η συμπεριφορά του προγράμματος
  είναι undefined, επίσης τα σήματα έρχονται στα προγράμματα όταν βρίσκονται σε idle κατάσταση οπώς έχουν τονίσει οι διδάσκωντες/βοηθοί.

• Για τη σωστή διαχείρηση μνήμης χρησιμοποιήθηκε το εργαλείο valgrind, πηγή https://valgrind.org/

• Γίνεται επίσης ένα print ενώς απλού prompt, travelMonitor:~$ , για να γνωρίζουμε πως τρέχουμε το προγράμμα.

• Για την είσοδο από το tty έχει χρησιμοποιηθεί το stdin το οποίο λειτουργεί και ως pointer σε αρχείο.

• Για την generic υλοποιήση χρησιμοποιήθηκε void pointer, με typedef σε έναν τύπο Item.
